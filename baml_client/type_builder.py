###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml-py
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# ruff: noqa: E501,F401
# flake8: noqa: E501,F401
# pylint: disable=unused-import,line-too-long
# fmt: off
import typing
from baml_py.baml_py import FieldType, EnumValueBuilder, EnumBuilder, ClassBuilder
from baml_py.type_builder import TypeBuilder as _TypeBuilder, ClassPropertyBuilder, ClassPropertyViewer, EnumValueViewer
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME


class TypeBuilder(_TypeBuilder):
    def __init__(self):
        super().__init__(classes=set(
          ["Add","Divide","MISSING","Multiply","SmallerProblems","Subtract",]
        ), enums=set(
          ["ToolChoose",]
        ), runtime=DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME)


    @property
    def Add(self) -> "AddAst":
        return AddAst(self)

    @property
    def Divide(self) -> "DivideAst":
        return DivideAst(self)

    @property
    def MISSING(self) -> "MISSINGAst":
        return MISSINGAst(self)

    @property
    def Multiply(self) -> "MultiplyAst":
        return MultiplyAst(self)

    @property
    def SmallerProblems(self) -> "SmallerProblemsAst":
        return SmallerProblemsAst(self)

    @property
    def Subtract(self) -> "SubtractAst":
        return SubtractAst(self)





class AddAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Add")
        self._properties: typing.Set[str] = set([ "tool_name",  "x",  "y", ])
        self._props = AddProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AddProperties":
        return self._props


class AddViewer(AddAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class AddProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def x(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("x"))

    @property
    def y(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("y"))

    

class DivideAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Divide")
        self._properties: typing.Set[str] = set([ "tool_name",  "x",  "y", ])
        self._props = DivideProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DivideProperties":
        return self._props


class DivideViewer(DivideAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class DivideProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def x(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("x"))

    @property
    def y(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("y"))

    

class MISSINGAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("MISSING")
        self._properties: typing.Set[str] = set([ "tool_name", ])
        self._props = MISSINGProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "MISSINGProperties":
        return self._props


class MISSINGViewer(MISSINGAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class MISSINGProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    

class MultiplyAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Multiply")
        self._properties: typing.Set[str] = set([ "tool_name",  "x",  "y", ])
        self._props = MultiplyProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "MultiplyProperties":
        return self._props


class MultiplyViewer(MultiplyAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class MultiplyProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def x(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("x"))

    @property
    def y(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("y"))

    

class SmallerProblemsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SmallerProblems")
        self._properties: typing.Set[str] = set([ "problem_statement",  "tool_chosen", ])
        self._props = SmallerProblemsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SmallerProblemsProperties":
        return self._props


class SmallerProblemsViewer(SmallerProblemsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SmallerProblemsProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def problem_statement(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("problem_statement"))

    @property
    def tool_chosen(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_chosen"))

    

class SubtractAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Subtract")
        self._properties: typing.Set[str] = set([ "tool_name",  "x",  "y", ])
        self._props = SubtractProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SubtractProperties":
        return self._props


class SubtractViewer(SubtractAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SubtractProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def x(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("x"))

    @property
    def y(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("y"))

    



class ToolChooseAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ToolChoose")
        self._values: typing.Set[str] = set([ "ADD_TWO_NUMBERS",  "SUBTRACT_TWO_NUMBERS",  "DIVIDE_TWO_NUMBERS",  "MULTIPLY_TWO_NUMBERS",  "MISSING", ])
        self._vals = ToolChooseValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ToolChooseValues":
        return self._vals


class ToolChooseViewer(ToolChooseAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class ToolChooseValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def ADD_TWO_NUMBERS(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("ADD_TWO_NUMBERS"))
    

    @property
    def SUBTRACT_TWO_NUMBERS(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("SUBTRACT_TWO_NUMBERS"))
    

    @property
    def DIVIDE_TWO_NUMBERS(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("DIVIDE_TWO_NUMBERS"))
    

    @property
    def MULTIPLY_TWO_NUMBERS(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("MULTIPLY_TWO_NUMBERS"))
    

    @property
    def MISSING(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("MISSING"))
    

    


__all__ = ["TypeBuilder"]